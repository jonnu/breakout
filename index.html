<!DOCTYPE html>
<html>
    <head>
        <title>Breakout</title>
        <meta charset="UTF-8" />
        <style>

        body {
            margin: 0;
        }

        </style>
    </head>
    <body>

        <canvas id="breakout" />

        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.js"></script>
        <script>

        // require.config({
        //     baseUrl: "",
        //     waitSeconds: 1
        // });

        define("breakout", ["breakout/manager", "breakout/entity/ball", "breakout/entity/paddle", "breakout/collider", "breakout/collider/manager"], function (Manager, Ball, Paddle, Collider, CollisionManager) {

            var canvas = document.getElementById("breakout");
            var context = canvas.getContext("2d");

            canvas.width = document.body.clientWidth;
            canvas.height = document.body.clientHeight;

            var manager = new Manager();
            var ball = new Ball(canvas.width / 2, canvas.height - 30, 6, new Collider());
            var paddle = new Paddle(canvas.width / 2, canvas.height - 20, 100, 10, new Collider());

            // ball.collider.register(paddle.collider, function (paddle) {

            //     // invert.
            //     console.log("two colliders (ball and paddle) are colliding!", this, arguments);
            //     this.dy = -this.dy;

            // });

            ball.onCollisionWith(paddle, function () {
                console.log("Collision", this, arguments);
            });

            // ball.onCollisionWith(paddle, function (Paddle) {
            //     console.log("I collided with Paddle:", Paddle);
            // });

            manager.register("ball", ball);
            manager.register("paddle", paddle);

            var Breakout = function () {};

            Breakout.prototype.render = function () {

                // flush
                context.clearRect(0, 0, canvas.width, canvas.height);

                // draw all entities
                for (var entity in manager.entities) {
                    manager.entities[entity].render && manager.entities[entity].render.call(manager.entities[entity], canvas, context);
                }

                // move all entities
                for (var entity in manager.entities) {
                    manager.entities[entity].move && manager.entities[entity].move.call(manager.entities[entity], canvas, context);
                }

                CollisionManager.check();
            };

            Breakout.prototype.init = function () {
                var game = new Breakout();
                setInterval(game.render, 10);
                return game;
            };

            return Breakout;
        });

        define("breakout/manager", function () {

            // entity manager.
            var Manager = function () {
                this.entities = {};
            };

            Manager.prototype.register = function (name, entity) {
                this.entities[name] = entity;
            };

            Manager.prototype.unregister = function (name, entity) {
                delete this.entities[name];
            };

            return Manager;
        });

        define("breakout/entity", ["breakout/collider/manager"], function (CollisionManager) {

            var Entity = function () {
                //console.log("Entity constructor", arguments);
            };

            Entity.prototype.onCollisionWith = function (entity, callback) {
                //this.collider.register(entity.collider, callback);
            };

            return Entity;
        });

        define("breakout/collider/manager", function () {

            var collidable = {};

            var CollisionManager = function () {
            };

            // CollisionManager.register = function (collider) {
            //     colliders[collider.guid] = collider;
            // }

            CollisionManager.register = function (entity) {
                //console.log("Check entity:", entity);
                collidable[entity.guid] = entity;
            }

            CollisionManager.unregister = function (entity) {
                delete collidable[entity.guid];
            };

            CollisionManager.check = function () {

                var collider, subscriber;
                for (var c_guid in collidable) {

                    collider = collidable[c_guid];

                    for (var s_guid in collider.subscribers) {

                        subscriber = colliders[s_guid];

                        // check if one bounding box is to the LEFT of the other.
                        if (collider.x > subscriber.x + subscriber.w || subscriber.x > collider.x + collider.w) {
                            continue;
                        }

                        // check if one bounding box is ABOVE the other.
                        if (collider.y + collider.h < subscriber.y || subscriber.y + subscriber.h < collider.y) {
                            continue;
                        }

                        // there seems to be a collision between these two colliders. trigger callbacks
                        for (var j = 0; j < collider.subscribers[s_guid].length; j++) {
                            collider.subscribers[s_guid][j].call(collider.entity, subscriber.entity);
                        }
                    }
                }
            };

            return CollisionManager;
        });

        define("breakout/helper", function () {

            function generateGuidOctet () {
                return Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1);
            };

            return {
                generateGuid: function () {
                    return generateGuidOctet() + generateGuidOctet() + '-' + generateGuidOctet() + '-' + generateGuidOctet() + '-' + generateGuidOctet() + '-' + generateGuidOctet() + generateGuidOctet() + generateGuidOctet();
                }
            };

        });

        define("breakout/collider", ["breakout/collider/manager", "breakout/helper"], function (Manager, Helper) {

            var Collider = function (x, y, w, h, entity) {

                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.subscribers = {};
                this.guid = Helper.generateGuid();

                Manager.register(this);
            };

            Collider.prototype.register = function (collider, callback) {

                if (!this.subscribers.hasOwnProperty(collider.guid)) {
                    this.subscribers[collider.guid] = [];
                }

                this.subscribers[collider.guid].push(callback);
            };

            Collider.prototype.reposition = function (x, y, w, h) {

                this.x = x;
                this.y = y;

                if (w !== undefined) {
                    this.w = w;
                }


                if (h !== undefined) {
                    this.h = h;
                }
            }

            Collider.prototype.render = function (canvas, context) {

                // context.beginPath();
                // context.lineWidth = 2;
                // context.strokeStyle = "red";
                // context.rect(this.x, this.y, this.w, this.h);
                // context.stroke();
                // context.closePath();
            }

            return Collider;
        });

        define("breakout/entity/ball", ["breakout/entity"], function (Entity) {

            var Ball = function (x, y, size, collider) {

                this.x = x;
                this.y = y;
                this.radius = size;
                this.dx = 2;
                this.dy = -2;

                this.collider = collider;
                this.collider.reposition(x, y, this.radius * 2, this.radius * 2);

                //collider.entity = this;
                //console.log("Ball created", this);

                Entity.call(this);
            };

            Ball.prototype = Object.create(Entity.prototype);
            Ball.prototype.constructor = Ball;

            Ball.prototype.render = function (canvas, context) {
                context.beginPath();
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fillStyle = "#0095DD";
                context.fill();
                context.closePath();

                this.collider.render(canvas, context);
            };

            Ball.prototype.move = function (canvas, context) {

                if (this.y + this.dy < this.radius || this.y + this.dy > canvas.height - this.radius) {
                    this.dy = -this.dy;
                }

                if (this.x + this.dx < this.radius || this.x + this.dx > canvas.width - this.radius) {
                    this.dx = -this.dx;
                }

                this.x += this.dx;
                this.y += this.dy;

                this.collider.reposition(this.x - this.radius, this.y - this.radius);
            };

            return Ball;
        });

        define("breakout/entity/paddle", ["breakout/entity"], function (Entity) {

            var Paddle = function (x, y, w, h, collider) {

                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;

                this.collider = collider;
                collider.entity = this;
                collider.reposition(x, y, w, h);

                console.log("Paddle created", this);

                Entity.call(this);

                document.addEventListener("keydown", this.keydown, false);
                document.addEventListener("keyup", this.keyup, false);
            };

            Paddle.prototype = Object.create(Entity.prototype);
            Paddle.prototype.constructor = Paddle;

            Paddle.prototype.render = function (canvas, context) {
                context.beginPath();
                context.rect(this.x, this.y, this.w, this.h);
                context.fillStyle = "#000000";
                context.fill();
                context.closePath();

                this.collider.render(canvas, context);
            };

            Paddle.prototype.move = function (canvas, context) {

                if (inputs.hasOwnProperty(37) && inputs[37] && this.x > 0) {
                    this.x = Math.max(this.x - 5, 0);
                }

                if (inputs.hasOwnProperty(39) && inputs[39] && this.x < canvas.width - this.w) {
                    this.x = Math.min(this.x + 5, canvas.width - this.w);
                }

                this.collider.reposition(this.x, this.y);
            };

            var inputs = {
            };

            Paddle.prototype.keyup = function (event) {
                inputs[event.keyCode] = false;
            }

            Paddle.prototype.keydown = function (event) {
                inputs[event.keyCode] = true;
            }

            return Paddle;
        });

        require(["breakout"], function (Game) {
            var Breakout = new Game();
            Breakout.init();
        });

        </script>

    </body>
</html>
